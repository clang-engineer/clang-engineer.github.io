---
title       : Thread 종류 정리
description : 
date        : 2024-03-07 09:32:27 +0900
updated     : 2024-03-07 09:33:16 +0900
categories  : [study, os]
tags        : [thread, os, user, kernel, hardware, green]
pin         : false
hidden      : false
---

프로그램은 컴퓨터상에서 세개의 level로 구분되어 실행되고 각 level은 해당 영역에서 스레드를 생성하고 관리한다. <br>
(유저 level에서 프로그램이 실행되고 OS level에서 커널을 통해 하드웨어 level에 접근한다.)
1. 유저(User) level
2. 커널(OS) level
3. 하드웨어 level (CPU, 메모리, Device)

> Thread는 하드웨어 스레드, OS 스레드, 네이티브 스레드, 커널 스레드, 유저 스레드, 그린 스레드 등 다양한 이름으로 불린다.


## 하드웨어 스레드
- 코어가 메모리에 어떤 작업을 하는 경우 대기하는 시간이 발생한다. 이때 코어가 대기하지 않고 다른 작업을 수행할 수 있도록 하는 것이 하드웨어 스레드이다.
- 인텔의 하이퍼스레딩 기술이 이에 해당한다. (물리적 코어가 1개인데 논리적 코어가 2개인 경우)
- 만약에 싱글 코어 CPU에서 하드웨어 스레드가 두개라면 OS는 이 CPU를 듀얼 코어로 인식하고 듀얼 코어에 맞춰서 OS 레벨의 스레드들을 스케쥴링 한다.

> Q. 인텔 듀얼 코어 CPU에 hyper-threading이 적용됐다면 하드웨어 스레드는 몇 개인가?
- A. 4개


## OS(커널) 스레드
- 운영체제가 직접 관리하는 스레드이다.
- 스레드의 생성, 스케쥴링, 컨텍스트 스위칭 등을 커널이 담당한다.
- OS스레드의 컨텍스트 스위칭 비용은 유저 스레드보다 크다. <br> (유저 스레드는 유저 레벨에서 스레드를 관리하기 때문에 커널이 개입하지 않는다.)
- OS 스레드는 시스템 콜을 통해 사용자 모드와 커널 모드를 오가며 실행된다.

| 모드	| 설명	| 특징 |
| --- | --- | --- |
| 사용자 모드 (User Mode) | 일반 애플리케이션 코드가 실행되는 영역 | 하드웨어 직접 접근 불가, 시스템 콜 필요 |
| 커널 모드 (Kernel Mode) | 운영체제(OS) 내부 코드가 실행되는 영역 | 하드웨어 직접 접근 가능, 보호된 메모리 사용 가능 |

> OS 스레드에서 사용자 모드와 커널 모드가 전환되는 과정
1. 애플리케이션 코드 실행 → 사용자 모드에서 실행 중
2. 파일을 읽거나 네트워크 요청 같은 시스템 콜을 호출함 (예: read(), write(), socket())
3. 시스템 콜을 호출하면 OS(커널)로 제어권이 넘어가면서 커널 모드로 전환됨
4. 커널이 필요한 작업(파일 읽기, 네트워크 요청 처리 등)을 수행함
5. 작업이 끝나면 다시 사용자 모드로 돌아감

### OS 스레드의 다른 이름
- 네이티브(native) 스레드 (*네이티브는 보통 운영체제를 의미한다.)
- 커널(kernel) 스레드
- 커널-레벨(kernel-level) 스레드
- OS-레벨(OS-level) 스레드

> Q. OS 스레드 여덟 개가 하이퍼 스레딩이 적용된 인텔 듀얼코어 위에서 동작한다면 OS스레드들을 어떻게 코어에 균등하게 할당할 수 있을까 ? 
- A. OS는 하드웨어 스레드를 4개로 인식하고 스케쥴링한다. 때문에 각 코어에 2개의 OS 스레드가 할당된다.

## 유저 스레드
- 스레드 개념을 프로그래밍 언어 레벨에서 추상화한 것.
- 유저 스레드가 CPU에서 실행되려면 OS 스레드와 반드시 연결돼야 한다.

### 유저 스레드와 OS 스레드를 연결하는 방법

1. One-to-One Model
- 스레드를 생성할 때마다 OS 스레드를 생성한다.
- 컨텍스트 스위칭 비용이 크다. (커널이 개입하기 때문)
- 스레드 관리를 OS에 위임한다. (스케쥴링 커널이 담당)
- 한 스레드가 블록되어도 다른 스레드가 실행될 수 있다.
- race condition이 발생할 수 있다.
- Java, C# 등에서 사용한다. 

2. Many-to-One Model
- 여러 개의 유저 스레드가 하나의 OS 스레드에 매핑된다.
- 컨텍스트 스위칭 비용이 적다. (유저 레벨에서 스레드를 관리하기 때문 >> 커널이 개입하지 않는다.)
- race condition 발생 가능성이 낮다. (유저 레벨에서 스레드를 관리하기 때문)
- os 스레드가 하나이기 때문에 멀티코어를 활용하지 못한다.
- 한 스레드가 블록되면 다른 스레드도 블록된다. (이를 해결하기 위해 Non-blocking I/O 개념이 나왔다.)

3. Many-to-Many Model
- 여러 개의 유저 스레드가 여러 개의 OS 스레드에 매핑된다.
- One-to-One Model과 Many-to-One Model의 장점을 결합한 모델이다.
- 멀티코어를 활용할 수 있고, 유저 레벨에서 스레드를 관리하기 때문에 컨텍스트 스위칭 비용이 적다. 하나의 유저 스레드가 블록되어도 다른 유저 스레드가 실행될 수 있다.
- Go에서 사용한다.


## 그린 스레드
- Java 초창기 버전은 Many-to-One Model을 사용했는데, 이때 유저 스레드를 그린 스레드라고 부른다.
- OS와 독립적으로 유저 레벨에서 스케쥴링되는 스레드이다.


> 출처 & 참고
- [쉬운코드](https://www.youtube.com/@ez./playlists)
