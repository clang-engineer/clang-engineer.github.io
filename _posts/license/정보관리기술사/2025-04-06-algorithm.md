---
title       : Algorithm
description : >-
date        : 2025-02-22 00:00:00 +0900
updated     : 2025-03-02 23:09:59 +0900
categories  : [license, 정보관리기술사]
tags        : [algorithm]
pin         : false
hidden      : true
---

## PART1. 자료구조(Data Structure)와 알고리즘(Algorithm)
### 1. 자료구조(Data Structure)
정의
> 기억 장치 내에 Data(자료)를 어떻게 표현할지, 표현된 자료를 효율적으로 저장하는지, 자료들 간의 관계는 어떠한지를 파악하여 여러 작업을 수행하기 위한 알고리즘을 연구하는 이론
> 자료의 표현 및 자료를 저장하기 위한 논리적인 구조와 그것과 관련된 연산

분류
> 자료구조는 크게 선형 자료구조와 비선형 자료구조로 나눌 수 있다. 선형 자료구조는 배열, 연결 리스트, 스택, 큐 등이 있으며, 비선형 자료구조는 트리, 그래프 등이 있다.

목적
>
- 효율성: 자료를 효율적으로 저장하고 검색하기 위해
- 추상화: 복잡한 데이터를 단순화하여 다루기 위해
- 재사용성: 이미 구현된 자료구조를 재사용하여 개발 시간을 단축하기 위해

### 2. 자료구조(Data Structure)의 구성, 형태, 단위

구성
> 자료구조는 자료와 정보로 구성된다. <br>
- 자료: 관찰이나 측정을 통하여 수집된 사실이나 수치
- 정보: 문제를 해길하는데 필요한 사실

형태
> 
- 단순구조: 정수, 실수, 문자, 문자열 등
- 선형구조: 배열, 연결 리스트, 스택, 큐, 데크 등
- 비선형구조: 트리, 그래프 등
- 파일구조: 순차파일, 색인파일, 해시파일 등

단위
> 
- Bit: 0 과 1로 정보표현, 정보의 최소단위
- Byte: 8개 Bit, 문자를 표현하기 위한 최소단위
- Word: Byte의 모임. Word(2byte), Fullword(4byte), Doubleword(8byte) 등
- Field: 자료처리의 최소단위, DB에서 Attibute와 상응
- Record: 하나 이상의 Field 모임, DB에서 Tuple과 상응. 논리적 처리 기본단위, 보조기억장치의 입출력 단위, 물리적으로는 Block에 해당.
- File: Record의 모임. 순차/색인/직접파일구조 
- Database: File의 집합. DB는 Data 모델에 따라 계층, 망, 관계형 구조

### 3. 알고리즘(Algorithm)의 정의, 조건, 접근 방법, 분석 방법
정의
> 주어진 문제를 해결하기 위한 방법을 추상화하여 일련의 단계적 절차를 논리적으로 기술해 놓은 명세서

조건
>
- 입력: 입력 자료가 1개 이상
- 출력: 결과 자료가 1개 이상
- 명확성: 각 단계가 모호하지 않고 명확해야 함
- 유한성: 알고리즘의 수행이 유한한 단계에서 종료되어야 함
- 유효성: 모든 명령은 실행 가능한 연산일 것

접근방법
> 
- 무작위 알고리즘(Randomized): 난수를 사용하여 문제를 해결하는 방법 (ex. 암호학, Quick 정렬, 양자 컴퓨터 알고리즘)
- 분할 정복 알고리즘(Divide & Conquer): 작은 문제로 분할하여 문제 해결하는 방법 (분할->정복->결합, ex. 병합정렬, 고속 푸리에 변환 문제)
- 동적 프로그래밍(Dynamic Programming): 분할정복기법과 같이 부분문제의 해를 결합해 최적화 문제를 해결 (ex. Matix 곱셈, Matrix Chain)
- 탐욕 알고리즘 (Greedy): 매순간 가장 좋아보이는 값을 선택하여 문제를 해결하는 방법 (ex. 허프만 코딩 기법, 배낭문제)
- 근사 알고리즘(Approximation): 최적의 해를 구하는 대신에 충분히 좋은, 유사한 해를 구하는 방법 (ex. 외판원 문제)

분석방법
>
- 공간 복잡도: 메모리 사용 최소
- 시간 복잡도: 
  + Worst Case: 최악의 경우
  + Best Case: 최선의 경우
  + Average Case: 평균적인 경우
- 성능 표기법:
  + Big-O: 상위 한계
  + Big-Omega: 하위 한계
  + Big-Theta: 상하위 한계

### 4. 알고리즘 실행시간을 추정하는데 사용되는 Big-O 표기법
> 알고리즘을 수행하는데 걸리는 시간을 수학적으로 표현한 것. 알고리즘의 성능을 분석하는데 사용됨.
> 알고리즘을 실제로 실행시키지 않고 실행시간을 추정해보기 위해 시간복잡도를 사용하여 실행시간을 추정하는 점근적 표기법

### 5. 알고리즘의 평가방법인 Time Complexity(시간 복잡도)와 Space Complexity(공간 복잡도)
시간 복잡도
> 알고리즘이 수행되는 시간의 양을 측정하는 방법. 입력 크기 n에 대한 함수로 표현됨.

공간 복잡도
> 알고리즘이 수행되는 동안 필요한 메모리의 양을 측정하는 방법. 입력 크기 n에 대한 함수로 표현됨.

### 6. 10진수 53을 2진수로 변환하고 2진수 11010을 10진수로 변환

10진수를 2진수로 변환
```cpp
#include <iostream>
using namespace std;
int main() {
    int decimal = 53;
    string binary = "";
    
    while (decimal > 0) {
        binary = to_string(decimal % 2) + binary; // 2진수의 나머지를 앞에 붙임
        decimal /= 2;
    }
    
    cout << "10진수 53의 2진수 표현: " << binary << endl;
    return 0;
}
```

2진수를 10진수로 변환
```cpp
#include <iostream>
#include <cmath>
using namespace std;
int main() {
    string binary = "11010";
    int decimal = 0;
    
    for (int i = 0; i < binary.length(); i++) {
        decimal += (binary[binary.length() - 1 - i] - '0') * pow(2, i);
    }
    
    cout << "2진수 11010의 10진수 표현: " << decimal << endl;
    return 0;
}
```


### 7. 10진수 0.6875를 2진수로 변환하고 그 결과를 다시 10진수로 표현
### 8. 2진수를 음수로 표현하는 방법 3가지 이상 나열
### 9. 알고리즘 표현 방법과 반복문인 for, while, do-while문을 사용하여 1에서 100까지 덧셈하는 code 예제와 순서도
### 10.아래 3개 A,B,C 알고리즘 사용시 n에 대한 전체 연산수를 구하시오.

- A
```sh
Sum n *n;
```
- B
```sh
for i < -1 to n do
    Sum Sum+n;
```
- C
```sh
for i < -1 to n do
    for j = 1 to n do
        Sum Sum+n;
```

### 11. 프로그램 언어에서 함수간 매개변수 전달기법인 Call-by-value, Call-by-reference, Call-by-name에 대해 실제 Code 예제를 보이시오.

### 12. C언어를 사용하여 정수를 이진수로 변환하는 프로그램을 작성하시오.

### 13. 자료 구ㅈ조에서 아래 Pointer 자료의 Memory Allocation(할당)을 표현하고 설명하시오.
```cpp
int a, b;
int *ptr;
a = 15;
ptr = &a;
b = *ptr;
```

--

## PART2. 재귀함수(Recursive Function) 
### 14.
### 15.
### 16.
### 17.
### 18.

--

## PART3. 배열(Array)과 연결 리스트(Linked List)
### 19.
### 20.
### 21.
### 22.
### 23.
### 24.
### 25.
### 26.

--

## PART4. 스택(Stack)과 큐(Queue)
### 27.
### 28.
### 29.
### 30.
### 31.
### 32.
### 33.
### 34.
--

## PART5. 정렬(Sorting)
### 35.
### 36.
### 37.
### 38.
### 39.
### 40.
### 41.
### 42.
### 43.
### 44.
### 45.
### 46.
### 47.
### 48.
### 49.
### 50.
### 51.
### 52.
### 53.
### 54.
### 55.
### 56.
### 57.

--

## PART6. 탐색(Searching)
### 58.
### 59.
### 60.
### 61.
### 62.
### 63.
### 64.
### 65.
### 66.
### 67.
### 68.
### 69.
### 70.
### 71.


--

## PART7. 산술식 표현과 트리(Tree)
### 72.
### 73.
### 74.
### 75.
### 76.
### 77.
### 78.
### 79.
### 80.
### 81.
### 82.
### 83.
### 84.
### 85.
### 86.
### 87.
### 88.
### 89.
### 90.
### 91.
### 92.
### 93.
### 94.
### 95.
### 96.
### 97.
### 98.
### 99.
### 100.
### 101.
### 102.
### 103.
### 104.
### 105.
### 106.
### 107.
### 108.
### 109.
### 110.
### 111.
### 112.

--

## PART8. 그래프(Graph)
### 113.
### 114.
### 115.
### 116.
### 117.
### 118.
### 119.
### 120.
### 121.
### 122.
### 123.
### 124.
### 125.
### 126.

--

## PART9. 기타 알고리즘
### 127.
### 128.
### 129.
### 130.
### 131.
### 132.
### 133.
### 134.
### 135.
### 136.
### 137.
### 138.
### 139.
### 140.
### 141.
### 142.
### 143.